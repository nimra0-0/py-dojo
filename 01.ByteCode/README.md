# Bytecode Demo

This repository contains a single script, `bytecode_demo.py`, that shows how to
compile Python source to a code object, inspect its bytecode, and execute the
resulting bytecode. The sample code computes the first _n_ Fibonacci numbers.

## Requirements

- Python 3.10+ (any modern CPython build works)

## What is ByteCode??

Before we move onto the implementation it's important to understand what ByteCode is, i won't be going into the details (since everything is available now on a click of a button ^-^), but i will touch the subject briefly just to give an idea.

Python `bytecode` is the `intermediate representation` of Python code generated by the `Python compiler`. When you write Python code, it is first compiled into `bytecode`, which is then executed by the `Python interpreter` (CPython VM).

Python bytecode allows Python code to be platform-independent and flexible. Here are a few reasons why:

- **Platform Independence**: Python bytecode can be executed on any platform that has a Python interpreter, without the need for recompilation.
- **Dynamic Typing**: Python bytecode is dynamically typed, which means that the type of a variable is determined at runtime, rather than at compile time.
- **Flexibility**: Python bytecode can be easily modified or extended, which makes it easier to add new features or functionality to the Python interpreter.

Overall, Python bytecode is an important part of the Python ecosystem, and it plays a key role in making Python a flexible and platform-independent language. Here is a simplified(there's a lot missing like how modules and imports are included)

```
   +----------------+
   | Python Source  |
   |   (.py file)   |
   +--------+-------+
            |
            |  Compilation (Python compiler)
            v
   +----------------+
   |   Bytecode     |
   |   (.pyc file)  |
   +--------+-------+
            |
            |  Execution (Python Virtual Machine)
            v
   +----------------+
   |   Interpreter  |
   |   (PVM executes|
   |    bytecode)   |
   +----------------+
```

Note: Python bytecode is specific to the Python version that generated it, so executing it with a different version can cause errors because the bytecode instructions or internal structures may have changed.

## Usage

Ok, so theory lessons are over so lets now get our hands dirty `*_*`:

1. Run the demo (adjust the sample size if needed):
   ```
   python bytecode_demo.py --sample-size 10
   ```
2. The script performs two steps:
   - Prints the bytecode disassembly using the `dis` module so you can inspect
     each opcode.
   - Executes the compiled code object via `exec` and prints the Fibonacci
     sequence to prove the bytecode runs as expected.

## Executing the Compiled `.pyc`

If you want to run the CPython bytecode file directly:

1. Compile the script:
   ```
   python -m py_compile bytecode_demo.py
   ```
2. A `.pyc` file will be generated under `__pycache__`, for example:
   `__pycache__/bytecode_demo.cpython-311.pyc`.
3. Run the bytecode file just like any script (update the path if your Python
   version differs):
   ```
   python __pycache__/bytecode_demo.cpython-311.pyc --sample-size 5
   ```

Running the `.pyc` proves that the bytecode alone is enough to execute the
program logic without the original `.py` file. Feel free to open the `.pyc`
with tools like `python -m dis bytecode_demo.py` or `python -m dis
__pycache__/bytecode_demo.cpython-311.pyc` for additional inspection..
